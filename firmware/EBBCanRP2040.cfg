###########################################################################################
# EBB Canbus RP2040
###########################################################################################

[mcu EBBCan] 
canbus_uuid: 53858b87e825

[mcu eddy]
canbus_uuid: 37617875b420

canbus_interface: can0

#[temperature_sensor EBB_NTC]
#sensor_type: Generic 3950
#sensor_pin: EBBCan:gpio28
#min_temp: -120
#max_temp: 100

#[adxl345]
#cs_pin: EBBCan:gpio1
#spi_software_sclk_pin: EBBCan:gpio2
#spi_software_mosi_pin: EBBCan:gpio0
#spi_software_miso_pin: EBBCan:gpio3
#axes_map: z,-y,x

#[resonance_tester]
#probe_points: 100, 100, 20
#accel_chip: adxl345

#[extruder]
#step_pin: EBBCan:gpio18
#dir_pin: EBBCan:gpio19
#enable_pin: !EBBCan:gpio17
#microsteps: 16
#rotation_distance: 40
#gear_ratio: 9:1
#nozzle_diameter: 0.400
#filament_diameter: 1.750
#heater_pin: EBBCan:gpio7
#sensor_type: MAX31865
#sensor_pin: EBBCan:gpio9
#spi_bus: spi1
#spi_software_sclk_pin: EBBCan:gpio10
#spi_software_mosi_pin: EBBCan:gpio8
#spi_software_miso_pin: EBBCan:gpio11
#rtd_nominal_r: 1000
#rtd_reference_r: 4300
#rtd_num_of_wires: 2
#rtd_use_50Hz_filter: True
#max_extrude_cross_section: 5
#control: pid
#pid_Kp: 33.093
#pid_Ki: 1.808
#pid_Kd: 151.397
#min_temp: 0
#max_temp: 350 
#max_extrude_only_distance: 400
#pressure_advance: 0.116
#pressure_advance_smooth_time: 0.02
#step_pulse_duration:0.000002
#instantaneous_corner_velocity: 2.5

#[verify_heater extruder]
#max_error: 120
#check_gain_time:20
#hysteresis: 5
#heating_gain: 2

#[tmc2209 extruder]
#uart_pin: EBBCan:gpio20
#run_current: 0.65
#stealthchop_threshold: 999999

#[filament_motion_sensor motion_sensor]
#detection_length: 7.0
#extruder: extruder
#switch_pin: ^EBBCan:PB3

#[filament_switch_sensor switch_sensor]
#pause_on_runout: True
#debounce_delay: 0
#switch_pin: EBBCan:PB4

#[heater_fan Heatbreak_Cooling_Fan]
#pin: EBBCan:gpio14
#max_power: 1.0
#shutdown_speed: 0
#cycle_time: 0.010
#kick_start_time: 0.100
#heater: extruder
#heater_temp: 10.0
#fan_speed: 1.0
#off_below: 0

#[fan]
#pin: EBBCan:gpio13
#max_power: 1.0
#shutdown_speed: 0
#cycle_time: 0.010
#hardware_pwm: False
#kick_start_time: 0.500
#heater: extruder
#heater_temp: 50.0
#fan_speed: 1.0
#off_below: 0


#[neopixel hotend_rgb]
#pin: EBBCan:gpio16
#chain_count: 3
#color_order: GRBW 

#[delayed_gcode hotend_rgb]
#initial_duration: 5.
#gcode:
    #{% if printer.extruder.temperature > 50 %}
        #SET_LED LED=hotend_rgb RED=1 GREEN=0 BLUE=0 INDEX=1 TRANSMIT=1
        #SET_LED LED=hotend_rgb RED=1 GREEN=0 BLUE=0 INDEX=2 TRANSMIT=1
        #SET_LED LED=hotend_rgb RED=1 GREEN=0 BLUE=0 INDEX=3 TRANSMIT=1
    #{% else %}
        #SET_LED LED=hotend_rgb RED=0 GREEN=1 BLUE=0 INDEX=1 TRANSMIT=1
        #SET_LED LED=hotend_rgb RED=0 GREEN=1 BLUE=0 INDEX=2 TRANSMIT=1
        #SET_LED LED=hotend_rgb RED=0 GREEN=1 BLUE=0 INDEX=3 TRANSMIT=1
    #{% endif %}
     #UPDATE_DELAYED_GCODE ID=hotend_rgb DURATION=5

#[bltouch]
#sensor_pin: ^EBBCan:gpio21
#control_pin: EBBCan:gpio22

## NPN and PNP proximity switch types can be set by jumper
#[probe]
#pin: ^EBBCan:gpio6

#[temperature_sensor btt_eddy_mcu]
#sensor_type: temperature_mcu # Sets the type of sensor for Klipper to read
#sensor_mcu: eddy # Sets the MCU of the eddy probe tempereature sensor
#min_temp: 10 # Sets the minimum tempereature for eddys tempereature sensor to operate
#max_temp: 100 # Sets the maximum tempereature for eddys tempereature sensor to operate

#[probe_eddy_current btt_eddy]
#sensor_type: ldc1612
#z_offset: 2.5
#i2c_address:
#i2c_mcu: eddy  # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the MCU you have used.
#i2c_bus: i2c0f # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the I2C bus you have used.
# Measure the offsets below using the method described here: https://www.klipper3d.org/Probe_Calibrate.html#calibrating-probe-x-and-y-offsets
# For a standard Voron stealthburner X carriage mount there should be no need to change the defaults below.
#x_offset: 0
#y_offset: -21
#reg_drive_current: 15

#[bed_mesh]
#horizontal_move_z: 10
#speed: 120
# For the mesh dimensions below, the coordinates need to be reachable by the center of the probe. To calculate coordinates that will work, use the formula below:
# mesh x min = position_min_x + greater_of (15mm or x_offset) <--- in this term, only consider the x offset if it is positive, ignore if negative.
# mesh y min = position_min_y + greater_of (15mm or y_offset) <--- in this term, only consider the y offset if it is positive, ignore if negative.
# mesh x max = position_max_x - greater_of (15mm or |x_offset|) <--- in this term, only consider the x offset if it is negative, ignore if positive.
# mesh y max = position_max_y - greater_of (15mm or |y_offset|) <--- in this term, only consider the y offset if it is negative, ignore if positive.
# Example: Consider that you have a 300 x 300 bed with the max x and y positions being 300 and the min being 0. Your probe offsets are -20 for X and 10 for Y
# For mesh x min we ignore the x offset term because it is negative. Therefore mesh x min = 15
# For mesh y min we do not ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y min = 15
# For mesh x max we do not ignore the x offset term because it is negative. It is also greater than 15. Therefore mesh x max = 280
# For mesh y max we ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y max = 285
# The final result would be mesh_min: 15, 15 mesh_max: 280, 285
#mesh_min: 16, 25  # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
#mesh_max: 786, 746 # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
#probe_count: 10, 10
#algorithm: bicubic
#bicubic_tension:0.2
#mesh_pps: 4, 4
#fade_start: 1.0
#fade_end: 30.0
#scan_overshoot: 8 

#[gcode_macro SET_GCODE_OFFSET]
#rename_existing: SET_GCODE_OFFSET_ORIG
#variable_restored: False  # Mark whether the var has been restored from NVM
#variable_runtime_offset: 0
#gcode:
  #{% if params.Z_ADJUST %}
    #SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE={ printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset + params.Z_ADJUST|float }
  #{% endif %}
  #{% if params.Z %}
    #{% set paramList = rawparams.split() %}
    #{% for i in range(paramList|length) %}
      #{% if paramList[i]=="Z=0" %}
        #{% set temp=paramList.pop(i) %}
        #{% set temp="Z_ADJUST=" + (-printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset)|string %}
        #{% if paramList.append(temp) %}{% endif %}
      #{% endif %}
    #{% endfor %}
    #{% set rawparams=paramList|join(' ') %}
    #SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE=0
  #{% endif %}
  #SET_GCODE_OFFSET_ORIG { rawparams }

# This macro automates a lot of the frequency mapping process and simplifies the steps significantly.
#[gcode_macro PROBE_EDDY_CURRENT_CALIBRATE_AUTO]
#gcode:
  #BED_MESH_CLEAR
  #G28 X Y
  #G90 # Abs positioning
  #G1 X620.5 Y203 F6000
  #{% if 'z' not in printer.toolhead.homed_axes %}
    #SET_KINEMATIC_POSITION Z={ printer.toolhead.axis_maximum.z-1 } # Allows the user to work it down until it touches.
  #{% endif %}
  #PROBE_EDDY_CURRENT_CALIBRATE CHIP=btt_eddy {rawparams}


#This macro is optional but useful if you want to run a rapid scan before each print. Simply uncomment it and add BED_MESH_SCAN to your print start code.
#[gcode_macro BED_MESH_CALIBRATE]
#rename_existing: BTT_BED_MESH_CALIBRATE
#gcode:
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=True #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
  #BTT_BED_MESH_CALIBRATE PROFILE=default METHOD=automatic
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=False #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg

#[gcode_macro BED_MESH_RAPID_CALIBRATE]
#gcode:
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=True #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
  #BTT_BED_MESH_CALIBRATE PROFILE=default METHOD=rapid_scan HORIZONTAL_MOVE_Z=5
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=False #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
