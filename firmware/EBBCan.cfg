###########################################################################################
# EBB Canbus
###########################################################################################

[mcu EBBCan] 
canbus_uuid: 31206502fbf7

[mcu eddy]
canbus_uuid: 37617875b420

canbus_interface: can0

[temperature_sensor EBB_NTC]
sensor_type: Generic 3950
sensor_pin: EBBCan: PA2
min_temp: -120
max_temp: 100

[adxl345]
cs_pin: EBBCan: PB12
spi_software_sclk_pin: EBBCan: PB10
spi_software_mosi_pin: EBBCan: PB11
spi_software_miso_pin: EBBCan: PB2
axes_map: z,-y,x

[extruder]
step_pin: EBBCan: PD0
dir_pin: EBBCan: PD1
enable_pin: !EBBCan: PD2
microsteps: 16
rotation_distance: 40
gear_ratio: 9:1
nozzle_diameter: 0.800
filament_diameter: 1.750
heater_pin: EBBCan: PB13
sensor_type: MAX31865
sensor_pin: EBBCan: PA4
spi_bus: spi1
rtd_nominal_r: 1000
rtd_reference_r: 4300
rtd_num_of_wires: 2
rtd_use_50Hz_filter: True
max_extrude_cross_section: 5
control: pid
pid_Kp: 22.911
pid_Ki: 1.232
pid_Kd: 106.537
min_temp: 0
max_temp: 500
max_extrude_only_distance: 400
pressure_advance: 0.116
pressure_advance_smooth_time: 0.02
step_pulse_duration:0.000002
instantaneous_corner_velocity: 2.5

[verify_heater extruder]
max_error: 120
check_gain_time:20
hysteresis: 5
heating_gain: 2

[tmc2209 extruder]
uart_pin: EBBCan: PA15
run_current: 0.65
stealthchop_threshold: 999999

#[filament_motion_sensor motion_sensor]
#detection_length: 7.0
#extruder: extruder
#switch_pin: ^EBBCan:PB3

#[filament_switch_sensor switch_sensor]
#pause_on_runout: True
#debounce_delay: 0
#switch_pin: EBBCan:PB4

#[temperature_fan extruder_partfan]
#pin: EBBCan: PA0
#max_power:1.0

#[heater_fan hotend_fan]
#pin: EBBCan: PA1

[neopixel hotend_rgb]
pin: EBBCan:PD3
chain_count: 3
color_order: GRBW 

[delayed_gcode hotend_rgb]
initial_duration: 5.
gcode:
    {% if printer.extruder.temperature > 50 %}
        SET_LED LED=hotend_rgb RED=1 GREEN=0 BLUE=0 INDEX=1 TRANSMIT=1
        SET_LED LED=hotend_rgb RED=1 GREEN=0 BLUE=0 INDEX=2 TRANSMIT=1
        SET_LED LED=hotend_rgb RED=1 GREEN=0 BLUE=0 INDEX=3 TRANSMIT=1
    {% else %}
        SET_LED LED=hotend_rgb RED=0 GREEN=1 BLUE=0 INDEX=1 TRANSMIT=1
        SET_LED LED=hotend_rgb RED=0 GREEN=1 BLUE=0 INDEX=2 TRANSMIT=1
        SET_LED LED=hotend_rgb RED=0 GREEN=1 BLUE=0 INDEX=3 TRANSMIT=1
    {% endif %}
     UPDATE_DELAYED_GCODE ID=hotend_rgb DURATION=5

#[bltouch]
#sensor_pin: ^EBBCan: PB8
#control_pin: EBBCan: PB9

## NPN and PNP proximity switch types can be set by jumper
#[probe]
#pin: ^EBBCan: PC13

#[output_pin PB5]
#pin: EBBCan: PB5

#[output_pin PB7]
#pin: EBBCan: PB7

#[output_pin PB6]
#pin: EBBCan: PB6

[temperature_sensor btt_eddy_mcu]
sensor_type: temperature_mcu # Sets the type of sensor for Klipper to read
sensor_mcu: eddy # Sets the MCU of the eddy probe tempereature sensor
min_temp: 10 # Sets the minimum tempereature for eddys tempereature sensor to operate
max_temp: 100 # Sets the maximum tempereature for eddys tempereature sensor to operate

[probe_eddy_current btt_eddy]
sensor_type: ldc1612
z_offset: 3
#i2c_address:
i2c_mcu: eddy  # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the MCU you have used.
i2c_bus: i2c0f # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the I2C bus you have used.
# Measure the offsets below using the method described here: https://www.klipper3d.org/Probe_Calibrate.html#calibrating-probe-x-and-y-offsets
# For a standard Voron stealthburner X carriage mount there should be no need to change the defaults below.
x_offset: 0
y_offset: -21
reg_drive_current: 15

[bed_mesh]
horizontal_move_z: 3
speed: 120
# For the mesh dimensions below, the coordinates need to be reachable by the center of the probe. To calculate coordinates that will work, use the formula below:
# mesh x min = position_min_x + greater_of (15mm or x_offset) <--- in this term, only consider the x offset if it is positive, ignore if negative.
# mesh y min = position_min_y + greater_of (15mm or y_offset) <--- in this term, only consider the y offset if it is positive, ignore if negative.
# mesh x max = position_max_x - greater_of (15mm or |x_offset|) <--- in this term, only consider the x offset if it is negative, ignore if positive.
# mesh y max = position_max_y - greater_of (15mm or |y_offset|) <--- in this term, only consider the y offset if it is negative, ignore if positive.
# Example: Consider that you have a 300 x 300 bed with the max x and y positions being 300 and the min being 0. Your probe offsets are -20 for X and 10 for Y
# For mesh x min we ignore the x offset term because it is negative. Therefore mesh x min = 15
# For mesh y min we do not ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y min = 15
# For mesh x max we do not ignore the x offset term because it is negative. It is also greater than 15. Therefore mesh x max = 280
# For mesh y max we ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y max = 285
# The final result would be mesh_min: 15, 15 mesh_max: 280, 285
mesh_min: 16, 25  # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
mesh_max: 786, 746 # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
probe_count: 10, 10
algorithm: bicubic
#bicubic_tension:0.2
#mesh_pps: 4, 4
#fade_start: 1.0
#fade_end: 30.0
#scan_overshoot: 8 

# Uncomment this if you are using Eddy as the probe AND the homing endstop
# Take note of the lines that should only be used if you have a KNOMI installed.
#[gcode_macro G28]
#rename_existing: G28.1
#gcode:
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=homing VALUE=True # Uncomment this if using a KNOMI and then remove the G28 macro from the KNOMI.cfg
  #G28.1 {rawparams}
  #{% if not rawparams or (rawparams and 'Z' in rawparams) %}
  #  PROBE
  #  SET_Z_FROM_PROBE
  #{% endif %}
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=homing VALUE=False # Uncomment this if using a KNOMI and then remove the G28 macro from the KNOMI.cfg

# Uncomment this if you are using Eddy as the probe AND the homing endstop
#[gcode_macro SET_Z_FROM_PROBE]
#gcode:
    #{% set cf = printer.configfile.settings %}
   # SET_GCODE_OFFSET_ORIG Z={printer.probe.last_z_result - cf['probe_eddy_current btt_eddy'].z_offset + printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset}
   # G90
   # G1 Z{cf.safe_z_home.z_hop}

[gcode_macro SET_GCODE_OFFSET]
rename_existing: SET_GCODE_OFFSET_ORIG
variable_restored: False  # Mark whether the var has been restored from NVM
variable_runtime_offset: 0
gcode:
  {% if params.Z_ADJUST %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE={ printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset + params.Z_ADJUST|float }
  {% endif %}
  {% if params.Z %}
    {% set paramList = rawparams.split() %}
    {% for i in range(paramList|length) %}
      {% if paramList[i]=="Z=0" %}
        {% set temp=paramList.pop(i) %}
        {% set temp="Z_ADJUST=" + (-printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset)|string %}
        {% if paramList.append(temp) %}{% endif %}
      {% endif %}
    {% endfor %}
    {% set rawparams=paramList|join(' ') %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE=0
  {% endif %}
  SET_GCODE_OFFSET_ORIG { rawparams }

# This macro automates a lot of the frequency mapping process and simplifies the steps significantly.
[gcode_macro PROBE_EDDY_CURRENT_CALIBRATE_AUTO]
gcode:
  BED_MESH_CLEAR
  G28 X Y
  G90 # Abs positioning
  G1 X620.5 Y203 F6000
  {% if 'z' not in printer.toolhead.homed_axes %}
    SET_KINEMATIC_POSITION Z={ printer.toolhead.axis_maximum.z-1 } # Allows the user to work it down until it touches.
  {% endif %}
  PROBE_EDDY_CURRENT_CALIBRATE CHIP=btt_eddy {rawparams}


#This macro is optional but useful if you want to run a rapid scan before each print. Simply uncomment it and add BED_MESH_SCAN to your print start code.
[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BTT_BED_MESH_CALIBRATE
gcode:
  SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=True #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
  BTT_BED_MESH_CALIBRATE PROFILE=default METHOD=automatic
  SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=False #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg

[gcode_macro BED_MESH_CALIBRATE_RAPID]
gcode:
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=True #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
  BTT_BED_MESH_CALIBRATE PROFILE=default METHOD=rapid_scan
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=False #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
